%
% author:	Ni Qingliang
% date:		2012-11-07
%
\startcomponent cpn-svc-model
\product wm-sw-arch

\chapter{业务模型}

\section{业务模型的要素}
业务模型有三个要素：
\startigNum
\item 如何驱动业务运转；
\item 业务间如何通信；
\item 业务如何运转。
\stopigNum

\subsection[sec:evt_drv]{事件驱动}

在我们的软件中，以【事件】来驱动程序运转，
事件驱动的好处就是在有外部事件输入的情况下才需要处理，空闲状态下什么都不需要做。
也就是说没有事件输入的情况下，程序处于暂停状态（对应于 Linux 中的  SLEEP）。
这样做的好处是显而易见的，避免程序空转消耗 CPU。
这个事件驱动模型中还用到了 Linux 的 epoll 机制，
同时它的可行性还得益于 Linux 中视一切为文件的思想
（比如， timer、 signal、 message queue、 socket、 pipe 等等在 Linux 中都是文件，
当然设备文件也是文件）。

其基本流程为：
\startigNum
\item[item:wait] 一个进程（线程）会执行系统调用 \ccmm{epoll_wait} 等在一系列文件上；
\item 其中任何一个文件有变化，比如 socket 收包， timer 超时，
都会以事件的形式唤醒此进程（线程）继续执行；
\item 而此进程则会根据事件源（哪个文件）、事件类型调用用户所注册的回调函数进行处理；
\item 处理完毕后则进行下一次等待，同\refitem{wait}。
\stopigNum

一般而言一项业务可能有多种状态（不同于 OS 中进程状态），不同状态下接受（可以处理）不同的事件，
这样就需要用到状态机，关于状态机参见\refsec{state_machine}。

\placefigure[here][fig:wm_evt_drv]
{事件驱动}
{\externalfigure[mp/umls-1.pdf]}

\reffig{wm_evt_drv} 中列出了业务执行模型中的主要 class。
其中 \ccmm{poller} 相当于轮询器，负责等待新事件的到来。
而 \ccmm{pollee} 为接受轮询者，为接口类，定义了一个接口 \ccmm{dispose}。
\ccmm{poller} 所提供的入口函数 \ccmm{run} 中会等待新事件的到来，
然后调用 \ccmm{pollee} 的 \ccmm{dispose} 接口来处理事件。
 \ccmm{serveree}、 \ccmm{connectee}、 \ccmm{clientee}、 \ccmm{timeree} 等均继承自
接口 \ccmm{pollee}，并实现了 \ccmm{pollee} 所定义的接口 \ccmm{dispose}。
其中前三个都与 socket 有关，目前以 TCP 实现。
后面视具体需求逐步添加对 message queue、 signal、 device file 等的支持。

\subsection{消息通信}

既然有多进程、多线程的存在，就必须为其制定通信方式，上一节中已经介绍了几种 \ccmm{pollee}，
可以优先选用 socket 方式以避免进程、线程的选择所带来的影响。
通信机制确立以后，还有一个问题就是消息格式，或者说数据序列化、反序列化的方式。
目前应用较广的是 msgpack 和 protobuf 两种 SDK，通过对比测试，基于性能和复杂性方面的考虑，
最终选用 msgpack 作为数据序列化、反序列化的工具，
为了简化其使用，对其进行了进一步封装，主要有三个（模板）类：
\startigNum
\item \ccmm{msg<mid_t id>}，即消息，其模板参数为消息 ID （枚举类型），
我们需要为每一个消息 ID 对此模板进行特化；
\startitem
\ccmm{recver}，即消息接收器，它提供了几个接口，使用示例\footnote{%
\useURL[wiki-table-driven][http://en.wikipedia.org/wiki/Table-driven]
\ccmm{switch / case} 仅为示例，如果消息比较多，则改用表 Table-Driven
\from[wiki-table-driven] 的方式来实现。}：
\startCPP
msg::recver pac;
pac.fill_from(obj);		// 1. 由 obj 接收消息
switch (pac.id()) {		// 2. 取得消息 ID
case msg::mid_t::test1: {
	msg::msg<msg::mid_t::test1> msg;
	pac.convert(msg);	// 3. 消息的反序列化
	...			// 4. 处理消息
	break;
\stopCPP
\stopitem
\startitem
\ccmm{sender}，即消息发送器，示例如下\footnote{%
\ccmm{fill_to} 会将消息 ID 和消息内容全部打包。}：
\startCPP
msg::sender pac;
msg::msg<msg::mid_t::test1> msg;
...				// 1. 填充消息
pac.fill_to(msg, obj);		// 2. 将消息序列化并由 obj 发送消息
\stopCPP
\stopitem
\stopigNum
其中 \ccmm{fill_from} 和 \ccmm{fill_to} 是两个模板成员函数，
会分别调用各自参数 \ccmm{obj} 的 \ccmm{recv} 和 \ccmm{send} 成员函数来接收和发送消息，
你也可以使用所重载的另外一个版本来自己指定 \ccmm{obj} 的成员函数。

\subsubsection{定义消息}
示例代码如下：
\startCPP
template<>
class msg<mid_t::test1> {
public:
	msg() : a(0), b(0) {}
public:
	uint8_t a;
	uint32_t b;
public:
	MSGPACK_DEFINE(a, b)
};
\stopCPP
其中 \ccmm{MSGPACK_DEFINE} 是一个宏，用来定义要（反）序列化哪些成员变量及其（反）序列化的顺序。

\subsection[sec:state_machine]{状态机}
每一项业务都会有自己的流程，而流程中又会有很多状态，用状态机描述流程具有简单、直观、易维护等特点。
而涉及到状态机的实现，我们既可以用一些比较成熟的库，也可以手工编写（handcrafted）。
这两种方式都能达到目的，但是前者的健壮性、可扩展性、可维护性无疑更好一些，
当然可能会有一些性能上的开销。
目前 C++ 语言的状态机库用的较多的为 boost 中的 MSM (meta state machine) 和 statechart，
其中 FSM 可以认为是一个简化版的 statechart，当前这两个库还有其他区别，比如对 UML 的支持。
我们最终选用的是 statechart，主要是基于代码的可读性和可维护性考虑，
当然是在其性能开销可以接受的情况下。

\useurl[msmVSsc][http://stackoverflow.com/questions/4275602/boost-statechart-vs-meta-state-machine]
\useurl[sc_perf][http://www.boost.org/doc/libs/1_53_0/libs/statechart/doc/performance.html]
\startnotepar
\noindent MSM 和 statechart 的比较：

\from[msmVSsc]

\noindent statechart 的性能：

\from[sc_perf]
\stopnotepar

\section{业务模型的物理视图}
每一项业务的内部结构如\reffig{fs_svc_phy_view}所示：

\input{fig/fs_svc_arch.tex}
\placefigure[here][fig:fs_svc_phy_view]
{业务模型的物理视图}
{\reuseMPgraphic{fsSvcArch}}

\subsection{控制器}
「控制器」是整个业务的核心，本质是一个 poller （参见\refsec{evt_drv}），
主要功能就是获取外部消息，
如 socket 消息（来自「Server」）、设备中断、定时器超时等等。
「控制器」收到消息后，如果发现是要通知「状态机」的，
则将消息转换成「状态机」所能识别的事件，并发送给「状态机」；否则就地处理。
另外「控制器」也会往外发送消息（通过「Server」），比如报告状态。
\subsection{Server}
「Server」是整个业务与其他模块交流的主要通道，一个业务本质是要提供一个 Service，
这里将「Server」实现为一个 TCP Server，其他模块可以给其发送消息，
比如状态查询、参数设置、业务启停等。所有消息都由「控制器」接收处理。
而「控制器」也可以通过「Server」给其他模块发送消息，比如报告状态，返回查询结果等。
\subsection{上下文}
「上下文」主要存放的是业务相关设备文件和「配置数据」，但都是引用，
这部分内容主要是给「状态机」用。
「上下文」的存在主要是为了限制状态机对这些数据的访问，
比如「配置数据」，不允许「状态机」对其更改，但其原始数据可以由「控制器」（处理配置消息时）更改，
其改动在「状态机」访问「上下文」的时候也可以体现。
\subsection{状态机}
「状态机」用于维护业务流的状态，接收来自「控制器」的事件，
并根据自身的状态来操控「上下文」中的设备，比如启动电机、启动高压板等；
然后完成自身状态的转换。

\startnotepar
「设备...」中除了「设备」还有「状态机」会用到的其他 pollee，如定时器。
\stopnotepar

下面介绍熔接机中一些主要业务的实现，每一种业务均从三方面进行介绍：
\startigBase
\item 消息，与其他模块交互用。
\item 流程，业务的主要流程。
\item 类图，业务的具体实现。
\stopigBase
\section{业务：熔接}

熔接是熔接机的核心业务，也是熔接机所有业务中涉及器件最多、最复杂的，本节主要介绍此业务的实现。

\subsection{消息}
熔接业务主要与 UI 部分进行交互，所使用的消息包括：
\startigBase
\item fs_start：来自 UI，用于启动熔接；
\item fs_continue：来自 UI （源自按键），继续熔接；
\item fs_stop：来自 UI，用于停止熔接；
\item fs_state：发往 UI，用于报告状态。
\stopigBase
目前实现中业务所需的配置数据，如熔接参数、操作选项等，均来由 fs_start 消息，
将来可以添加一个不带配置数据的 start 消息，这样只有第一次启动熔接的时候需要发送 fs_start，
后面如果配置数据没有变化，就只需发送不带配置数据的 start 消息即可。

\subsection{流程}

\reffig{fs_sm}是熔接业务的主要流程图。

\placefigure[here][fig:fs_sm]
{熔接业务流程图}
{\externalfigure[mp/umls-2.pdf]}

为了便于理解，\reffig{fs_sm}中只画出了主要流程。
由\reffig{fs_sm}可以看出，熔接业务主要有两大状态，一为「idle」，即空闲态；
一为「running」，即运行态。

「idle」是熔接业务的初始状态。目前此状态下主要处理的事件是 evStart，
由此业务的控制器根据消息 fs_start 转换而来。
当收到此事件后，转变为「running」状态。

「running」状态中的所有子状态都可以看作是熔接的一个步骤，这些步骤在正常情况下是顺序跳转的。
对于任何一个步骤而言，
如果收到了 evStop 事件（由控制器根据消息 fs_stop 转换而来），
或者出现了错误则跳转到「idle」态，
如果是出现了错误，还要通过控制器发送消息 fs_state 上报错误讯息。
熔接结束也会跳转到「idle」态，并上报状态。
此状态下所处理的事件列表：
\startigBase
\item evStop：停止熔接，收到此事件后会转入「idle」态，并执行一些初始化操作，比如电机复位。
\item evContinue：继续熔接，由消息 fs_continue 转换而来，
当子状态为「pause1」和「pause2」时接收到此事件会跳转到下一个状态。
\item evEntryAct：此事件为状态机内部事件，由状态机进入某一个状态时自发自收，
比如，进入「push1」状态后就会发送此事件，接收到此事件后会检查光纤间距是否达到了预设值，
如果是，则跳转到下一状态，否则操控电机。
\item evMotorStop：电机停止事件，此事件由电机中断出发，代表电机运行完成，可以继续操控电机了。
\item evHvbTimeout：高压板放电时间已经达到了预设值，收到此事件后关闭高压板，不再放电。
\stopigBase

\startnotepar
控制器在接收到配置数据后需要判断是否位于「running」态，如果是，则丢弃配置数据并回告错误讯息。
即熔接业务运行时不允许修改配置数据。

另外，「running」中的子状态发生变化时（正常流程）是否需要上报？
如果 UI 上除图像外还要以文字的形式显示当前状态，则需要上报，暂时不上报，如有需要再添加。
\stopnotepar

\subsection{类图}

\reffig{fs_class_diag} 是熔接业务的类图（仅包括主要类）。
\placefigure[here][fig:fs_class_diag]
{熔接业务类图}
{\externalfigure[mp/fs_class_diag-1.pdf]}
由图中可以看出，熔接业务主要由三个类构成：
\startigBase
\item fusion_splicer：是此业务的核心类，继承自执行模型中的「poller」，
相当于业务的「控制器」；
\item fs_sm：是此业务的「状态机」；
\item fs_ctx：是此业务的「上下文」。
\stopigBase
下面分别介绍这三个类（只由代码主干，其他以 \ccmm{...} 取代）。

\subsubsection{类： fusion_splicer}

\startCPP
class fusion_splicer : public exemodel::poller {
	...
private:
	/// 处理 poller 由 m_svr 收到的消息
	void __svr_cb(exemodel::serveree::args_t & args);
	/// 分别处理四个电机的中断
	void __motorLX_cb(motor::args_t & args);
	void __motorLY_cb(motor::args_t & args);
	void __motorRX_cb(motor::args_t & args);
	void __motorRY_cb(motor::args_t & args);
private:
	/// 状态机用此函数上报状态
	void __report(const std::string & info);
private:
	exemodel::serveree m_svr;	/// server，用于与其他模块通信
	msg::recver m_recver;		/// 消息接收器，与 m_svr 配合使用
	msg::sender m_sender;		/// 消息发送器，与 m_svr 配合使用

	camera	m_camera;	/// 摄像头
	motor	m_motorLX;	/// 左侧 X 轴电机
	motor	m_motorLY;	/// 左侧 Y 轴电机
	motor	m_motorRX;	/// 右侧 X 轴电机
	motor	m_motorRY;	/// 右侧 Y 轴电机
	hvb	m_hvb;		/// 高压板

	cfg_data_t m_cfg;	/// 配置数据

	svcFS::fs_ctx m_ctx;	/// 上下文
	svcFS::fs_sm m_sm;	/// 状态机
};
\stopCPP

此类在构造函数中会将摄像头、电机、高压板、配置数据等的引用添加到 \cvar{m_ctx} 中，
将 \cvar{__report} 和 \cvar{m_ctx} 都传递给 \cvar{m_sm}。

\capi{__svr_cb} 中会处理收到的消息，并将其转换成事件发送给 \cvar{m_sm}。

\subsubsection{类： fs_ctx}

\startCPP
class fs_ctx {
	...
public:
	camera	& m_camera;		/// 摄像头
	motor	& m_motorLX;		/// 左侧 X 轴电机
	motor	& m_motorLY;		/// 左侧 Y 轴电机
	motor	& m_motorRX;		/// 右侧 X 轴电机
	motor	& m_motorRY;		/// 右侧 Y 轴电机
	hvb	& m_hvb;		/// 高压板
	const cfg_data_t & m_cfg;	/// 配置数据
};
\stopCPP

此类中主要存储的是相关设备以及配置数据的引用，注意配置数据时 \cqlf{const} 引用，
即状态机在使用此类时不能修改配置数据。为了方便状态机的使用，本来可以为此类添加一些接口，
但考虑到控制的复杂性，可能要添加的接口很多，因此所有引用都做成 \ckey{public} 的，
由状态机直接访问。

\subsubsection{类： fs_sm}

\startCPP
struct stIdle;	/// 初始状态
struct fs_sm : boost::statechart::state_machine< fs_sm, stIdle > {
	...
public:
	fs_ctx & m_ctx;		/// 上下文的引用
	std::function<void(const std::string & )> m_reporter;	/// 用于上报状态的回调
};
\stopCPP

状态机里面主要由两项内容：一是上下文的引用，一是用于上报状态的回调，均在构造时确定。

\reftab{fs_state_list}中列出了熔接业务状态机中的所有状态及相应的类名。

\placetable[here][tab:fs_state_list]{熔接业务状态列表}{
\input{tbl/tbl_fs_list.tex}
}

下面以 \ctype{stPush1} 的代码为例介绍状态机的执行方式：
\subsubsubsection{状态： push1}
\startCPP
struct stPush1 : sc::state< stPush1, stRunning > {
	/// 此状态下可以处理下列三种事件：
	typedef boost::mpl::list<
		sc::custom_reaction< evEntryAct >,
		sc::custom_reaction< evMotorStop<motorId_t::LX> >,
		sc::custom_reaction< evMotorStop<motorId_t::RX> >
	> reactions;
public:
	stPush2(my_context ctx)
	: my_base(ctx)
	{
		/// 进入此状态后先自发自收事件 evEntryAct
		post_event(evEntryAct());
	}

	sc::result react(const evEntryAct &)
	{
		if (两根光纤均已到位) {
			/// 跳转到清洁放电状态
			return transit<stClearing>();
		}

		if (左侧光纤没有到位) {
			/// \todo 操控左侧 X 轴电机
		}

		if (右侧光纤没有到位) {
			/// \todo 操控右侧 X 轴电机
		}

		/// 维持此状态不变
		return discard_event();
	}

	sc::result react(const evMotorStop<motorId_t::LX> &)
	{
		if (左侧光纤没有到位) {
			/// \todo 操控左侧 X 轴电机
		}

		if (右侧光纤已经到位) {
			/// 此时两根光纤均已到位
			/// 跳转到清洁放电状态
			return transit<stClearing>();
		}

		/// 维持此状态不变
		return discard_event();
	}

	sc::result react(const evMotorStop<motorId_t::RX> &)
	{
		if (右侧光纤没有到位) {
			/// \todo 操控右侧 X 轴电机
		}

		if (左侧光纤已经到位) {
			/// 此时两根光纤均已到位
			/// 跳转到清洁放电状态
			return transit<stClearing>();
		}

		/// 维持此状态不变
		return discard_event();
	}
};
\stopCPP

\startnotepar
可能需要添加定时器来检查电机是否已经停止运行，以避免丢中断所带来的问题。
\stopnotepar

%\color[red]{\bfa\textbackslash\textbackslash TODO： 请添加相关内容。}
\stopcomponent
