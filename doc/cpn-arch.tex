%
% author:	Ni Qingliang
% date:		2011-02-11
%
\startcomponent cpn-arch
\product wm-sw-arch

\chapter{软件架构}
\section{总体架构}
软件总体架构如\reffig{wm_sw_arch} 所示，
共分为两大部分，一是应用（图的上半部分），一是驱动（图的下半部分）。
应用主要实现的是 GUI 以及熔接机的主要业务逻辑，另外还包含存档、读档等功能；
而此处的驱动为广义的驱动，不光包含驱动本身，还包含供应用使用的 Agent。
就总体架构而言，就这两个层次，层次较少有利于减少性能损耗。
目前考虑以多线程的方式实现，但在具体实施时可能会考虑往多进程迁移的可能，
尽量减少业务代码对多进程、多线程的依赖。

\input{fig/wm_sw_arch.tex}
\placefigure[here][fig:wm_sw_arch]
{熔接机软件总体架构}
{\reuseMPgraphic{wmSwArch}}

\reffig{wm_sw_arch}中的箭头所展示的主要是调用关系。

\section{应用部分}
应用部分主要采用 MVC 模式，
此模式主要目的是将业务逻辑和 UI 分离开，
以便开发工作的分工和组件的重用，同时也可以比较方便的更换 GUI 框架（如果需要的话）。

【视图】就是熔接机软件的 GUI，负责数据的呈现；
【模型】就是熔接机软件的业务逻辑，比如各参数之间的约束关系，所有业务数据也存储在其中；
【控制器】负责【视图】和【模型】之间的通信。

应用部分所采用的 GUI 框架为 QT（E），
从 QT4 开始，加入了对 MVC 的支持，此模式可以很好的与 QT 协同工作。
【模型】部分应尽量减少对 QT 的依赖。

\subsection{（业务）模型}
此部分是整个熔接机软件的核心，所有业务逻辑均在其内。
根据熔接机软件的特点，此部分模块结构如\reffig{wm_model_arch}所示。

\input{fig/wm_model_arch.tex}
\placefigure[here][fig:wm_model_arch]
{业务模型}
{\reuseMPgraphic{wmModelArch}}

熔接机软件的一个特点就是大量配置数据，
\reffig{wm_model_arch}中除了这一点还有另外一个要素，
就是【业务流】。
这两个要素分别以动态和静态的形式对熔接机软件进行了描述。

【业务流】可以认为是熔接机的主要功能，如熔接、加热等，
每个【业务流】都是一个动态的过程，
这个动态过程由【SPC】表示，即业务流控制器，
他控制着业务的整个流程，或者说熔接、加热等功能就是由【SPC】来执行的。
在其执行过程中，
通过调用设备驱动的【Agent】来访问硬件（参见\reffig{wm_sw_arch}）。
另外【SPC】在执行过程中还需要访问【配置数据】
（可能包括部分或全部【全局配置数据】，视每种业务的具体情况而定），
这些配置数据即用户所配置的一些参数，用于控制整个流程。
另外执行过程还会产生一些状态数据
（某些【状态数据】的变化可能需要通知【控制器】，\reffig{wm_model_arch}中没有画出）。

【控制器】会读写【（全局）配置数据】，
但只能读取【状态数据】，不能对其进行写操作。
另外【控制器】还会控制【SPC】的启动和停止
（某些业务的启动和/或停止可能是自动的，无须【控制器】介入）。

\startnotepar
配置数据之间的约束在【配置数据】内部完成。
每个【SPC】启动后以独立线程的形式执行相应的业务流。
每个【SPC】启动后可能会锁定对部分或全部【配置数据】（可能包括【全局配置数据】）的修改。
\stopnotepar

\startnotepar
此处讨论的【业务流】仅限于产品的特有功能，
不包括一些通用功能（如电池管理、系统时间管理等），
这些通用功能由【视图】部分直接与 OS 交互来完成。
\stopnotepar

\section{驱动部分}
每个驱动分成 Agent 和 Driver 两部分，
在 GNU / Linux 上，
Driver 为内核模块（.ko），
Agent 为动态库（.so）。
就我们的设备而言，不会出现两个程序共享同一设备的情况，
为了方便开发调试，我们采用【用户态驱动】。
虽然如此，但不一定严格按照【用户态驱动】的模式进行开发，
考虑到中断，每个驱动还是需要有内核模块来处理；
因此此处对【用户态驱动】进行推广，
就是将业务逻辑尽量放在用户空间执行（对应于 Agent），
除非必要，才将其放在内核空间中执行（对应于 Driver，如中断）。
当然每个驱动也可以根据实际需求，自行决定哪些工作放在用户空间执行，哪些工作放在内核空间执行。

如此， Driver 仅提供访问硬件的途径，并对其基本功能作简单的封装，
甚至仅提供 mmap，即内存映射，使得用户空间可以直接访问硬件寄存器。
在实现驱动部分时，需要考虑在 PC 上模拟运行的情况（GNU / Linux 的引入为模拟提供了极大的便利），
Driver 中的内容越少，则越容易模拟，反之则会比较困难。
理想情况下，除了 Driver，
应用部分以及驱动中的 Agent 均可以在 PC 上进行调测（需要实现 Driver 的模拟版本）。

相对于 Driver， Agent 提供了对硬件功能更高层次的抽象。
对每种硬件，需要仔细分析需求及其功能，使得定义的接口既能很好的屏蔽硬件细节，
又能提供很好的灵活性（以适配其他功能类似，型号不同的硬件）。

\section{其他}

\subsection{关于测试}

考虑到【自动化测试】的便利，可以考虑引入【CUI】。
由于目前我们考虑采用多线程的方式，【CUI】与【GUI】不方便共存。
所以业务部分，即【模型】可以做成程序库，
而【CUI】则可取代\reffig{wm_sw_arch}中的【视图】部分
（可能也包括【控制器】的部分功能）。

\subsection{关于大数据量}
软件中可能存在大数据量的传输，如视频的显示，
可以为这种数据开个绿色通道，由【视图】直接与相关驱动交互来完成数据传输。

\stopcomponent
